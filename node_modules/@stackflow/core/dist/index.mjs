var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/utils/compareBy.ts
function compareBy(a, b, selector) {
  const $a = selector(a);
  const $b = selector(b);
  if ($a < $b) {
    return -1;
  }
  if ($a === $b) {
    return 0;
  }
  return 1;
}

// src/utils/divideBy.ts
var divideBy = (arr, predicate) => {
  const satisfied = [];
  const unsatisfied = [];
  arr.forEach((element) => {
    if (predicate(element)) {
      satisfied.push(element);
    } else {
      unsatisfied.push(element);
    }
  });
  return [satisfied, unsatisfied];
};

// src/utils/findIndices.ts
function findIndices(arr, compare) {
  return arr.map((e, i) => compare(e) ? i : void 0).filter((output) => typeof output === "number");
}

// src/utils/time.ts
var dt = 0;
var memt = 0;
var time = () => {
  const t = (/* @__PURE__ */ new Date()).getTime();
  if (memt === t) {
    dt += 1;
  } else {
    memt = t;
    dt = 0;
  }
  return (t * 1e3 + dt) / 1e3;
};

// src/utils/id.ts
function id() {
  return (time() * 1e3).toString(16);
}

// src/utils/last.ts
function last(arr) {
  return arr.length === 0 ? void 0 : arr[arr.length - 1];
}

// src/utils/omit.ts
function omit(obj, fields) {
  const output = __spreadValues({}, obj);
  fields.forEach((field) => {
    delete output[field];
  });
  return output;
}

// src/utils/once.ts
function once(cb) {
  let called = false;
  return () => {
    if (called) {
      return;
    }
    called = true;
    cb();
  };
}

// src/utils/uniqBy.ts
function uniqBy(arr, by) {
  const valueMap = /* @__PURE__ */ new Map();
  return [...arr].reverse().filter((item) => {
    const key = by(item);
    if (key === null) {
      return true;
    }
    const exists = !!valueMap.get(key);
    valueMap.set(key, true);
    return !exists;
  }).reverse();
}

// src/activity-utils/findTargetActivityIndices.ts
function isActivityNotExited(activity) {
  return !activity.exitedBy;
}
function compareActivitiesByEventDate(a1, a2) {
  return a2.enteredBy.eventDate - a1.enteredBy.eventDate;
}
function findLatestActiveActivity(activities) {
  return activities.filter(isActivityNotExited).sort(compareActivitiesByEventDate)[0];
}
function findTargetActivityIndices(activities, event, context) {
  const targetActivities = [];
  switch (event.name) {
    case "Replaced": {
      const alreadyExistingActivityIndex = last(
        findIndices(activities, (activity) => activity.id === event.activityId)
      );
      if (alreadyExistingActivityIndex !== void 0) {
        break;
      }
      const sorted = activities.slice().sort(compareActivitiesByEventDate).filter(isActivityNotExited);
      const isTransitionDone = context.now - event.eventDate >= context.transitionDuration;
      const transitionState = event.skipEnterActiveState || isTransitionDone ? "enter-done" : "enter-active";
      if (transitionState === "enter-done") {
        const range = sorted.findIndex(
          (activity) => !(event.skipEnterActiveState && activity.enteredBy.name === "Replaced" && activity.transitionState === "enter-active")
        );
        return sorted.slice(0, range + 1).map((a) => activities.indexOf(a));
      }
      break;
    }
    case "Popped": {
      const sorted = activities.filter(isActivityNotExited).sort(compareActivitiesByEventDate);
      const latestActivity = sorted.slice(0, sorted.length - 1)[0];
      if (latestActivity) {
        targetActivities.push(activities.indexOf(latestActivity));
      }
      break;
    }
    case "StepPushed":
    case "StepReplaced": {
      const latestActivity = findLatestActiveActivity(activities);
      if (latestActivity) {
        if (event.targetActivityId && event.targetActivityId !== latestActivity.id) {
          break;
        }
        targetActivities.push(activities.indexOf(latestActivity));
      }
      break;
    }
    case "StepPopped": {
      const latestActivity = findLatestActiveActivity(activities);
      if (latestActivity && latestActivity.steps.length > 1) {
        if (event.targetActivityId && event.targetActivityId !== latestActivity.id) {
          break;
        }
        targetActivities.push(activities.indexOf(latestActivity));
      }
      break;
    }
    default:
      break;
  }
  return targetActivities;
}

// src/activity-utils/findNewActivityIndex.ts
function findNewActivityIndex(activities, event) {
  switch (event.name) {
    case "Pushed":
    case "Replaced": {
      const alreadyExistingActivityIndex = last(
        findIndices(activities, (activity) => activity.id === event.activityId)
      );
      return alreadyExistingActivityIndex != null ? alreadyExistingActivityIndex : activities.length;
    }
    default:
      return -1;
  }
}

// src/activity-utils/makeActivityFromEvent.ts
function makeActivityFromEvent(event, transitionState) {
  return {
    id: event.activityId,
    name: event.activityName,
    transitionState,
    params: event.activityParams,
    context: event.activityContext,
    steps: [
      {
        id: event.activityId,
        params: event.activityParams,
        enteredBy: event,
        zIndex: -1
      }
    ],
    enteredBy: event,
    isTop: false,
    isActive: false,
    isRoot: false,
    zIndex: -1
  };
}

// src/activity-utils/makeReducer.ts
function makeReducer(reducerMap) {
  return (target, event) => {
    const reducer = reducerMap[event.name].bind(reducerMap);
    if (reducer) {
      return reducer(target, event);
    }
    throw new Error(`No reducer for event ${JSON.stringify(event)}`);
  };
}

// src/activity-utils/makeActivitiesReducer.ts
function noop(activities) {
  return activities;
}
function makeActivitiesReducer({
  transitionDuration,
  now,
  resumedAt
}) {
  return makeReducer({
    /**
     * Push new activity to activities
     */
    Pushed(activities, event) {
      const isTransitionDone = now - (resumedAt != null ? resumedAt : event.eventDate) >= transitionDuration;
      const transitionState = event.skipEnterActiveState || isTransitionDone ? "enter-done" : "enter-active";
      const reservedIndex = findNewActivityIndex(activities, event);
      return [
        ...activities.slice(0, reservedIndex),
        makeActivityFromEvent(event, transitionState),
        ...activities.slice(reservedIndex + 1)
      ];
    },
    /**
     * Replace activity at reservedIndex with new activity
     */
    Replaced(activities, event) {
      var _a, _b;
      const isTransitionDone = now - (resumedAt != null ? resumedAt : event.eventDate) >= transitionDuration;
      const reservedIndex = findNewActivityIndex(activities, event);
      const transitionState = (_b = (_a = activities[reservedIndex]) == null ? void 0 : _a.transitionState) != null ? _b : event.skipEnterActiveState || isTransitionDone ? "enter-done" : "enter-active";
      return [
        ...activities.slice(0, reservedIndex),
        makeActivityFromEvent(event, transitionState),
        ...activities.slice(reservedIndex + 1)
      ];
    },
    /**
     * noop
     */
    Initialized: noop,
    ActivityRegistered: noop,
    Popped: noop,
    StepPushed: noop,
    StepReplaced: noop,
    StepPopped: noop,
    Paused: noop,
    Resumed: noop
  });
}

// src/activity-utils/makeActivityReducer.ts
function noop2(activity) {
  return activity;
}
function makeActivityReducer(context) {
  return makeReducer({
    /**
     * Change transition state to exit-done
     */
    Replaced: (activity, event) => __spreadProps(__spreadValues({}, activity), {
      exitedBy: event,
      transitionState: "exit-done"
    }),
    /**
     * Change transition state to exit-done or exit-active depending on skipExitActiveState
     */
    Popped: (activity, event) => {
      var _a;
      const isTransitionDone = context.now - ((_a = context.resumedAt) != null ? _a : event.eventDate) >= context.transitionDuration;
      const transitionState = event.skipExitActiveState || isTransitionDone ? "exit-done" : "exit-active";
      return __spreadProps(__spreadValues({}, activity), {
        exitedBy: event,
        transitionState,
        params: transitionState === "exit-done" ? activity.steps[0].params : activity.params,
        steps: transitionState === "exit-done" ? [activity.steps[0]] : activity.steps
      });
    },
    /**
     * Replace step params
     * Push new step
     */
    StepPushed: (activity, event) => {
      var _a;
      const newRoute = {
        id: event.stepId,
        params: event.stepParams,
        enteredBy: event,
        zIndex: activity.zIndex,
        hasZIndex: (_a = event.hasZIndex) != null ? _a : false
      };
      return __spreadProps(__spreadValues({}, activity), {
        params: event.stepParams,
        steps: [...activity.steps, newRoute]
      });
    },
    /**
     * Replace step params
     * Replace the last step
     */
    StepReplaced: (activity, event) => {
      var _a;
      const newRoute = {
        id: event.stepId,
        params: event.stepParams,
        enteredBy: event,
        zIndex: activity.zIndex,
        hasZIndex: (_a = event.hasZIndex) != null ? _a : false
      };
      return __spreadProps(__spreadValues({}, activity), {
        params: event.stepParams,
        steps: [
          ...activity.steps.slice(0, activity.steps.length - 1),
          newRoute
        ]
      });
    },
    /**
     * Pop the last step
     * If there are params in the previous step, set them as the new params
     */
    StepPopped: (activity, event) => {
      var _a;
      activity.steps.pop();
      const beforeActivityParams = (_a = last(activity.steps)) == null ? void 0 : _a.params;
      return __spreadProps(__spreadValues({}, activity), {
        params: beforeActivityParams != null ? beforeActivityParams : activity.params
      });
    },
    /**
     * noop
     */
    Initialized: noop2,
    ActivityRegistered: noop2,
    Pushed: noop2,
    Paused: noop2,
    Resumed: noop2
  });
}

// src/activity-utils/makeStackReducer.ts
function withPauseReducer(reducer) {
  return (stack, event) => {
    if (stack.globalTransitionState === "paused") {
      return __spreadProps(__spreadValues({}, stack), {
        pausedEvents: stack.pausedEvents ? [...stack.pausedEvents, event] : [event]
      });
    }
    return reducer(stack, event);
  };
}
function withActivitiesReducer(reducer, context) {
  return (stack, event) => {
    const activitiesReducer = makeActivitiesReducer({
      transitionDuration: stack.transitionDuration,
      now: context.now,
      resumedAt: context.resumedAt
    });
    const activityReducer = makeActivityReducer({
      transitionDuration: stack.transitionDuration,
      now: context.now,
      resumedAt: context.resumedAt
    });
    const activities = activitiesReducer(stack.activities, event);
    const targetActivityIndices = findTargetActivityIndices(
      stack.activities,
      event,
      { transitionDuration: stack.transitionDuration, now: context.now }
    );
    for (const targetActivityIndex of targetActivityIndices) {
      activities[targetActivityIndex] = activityReducer(
        activities[targetActivityIndex],
        event
      );
    }
    const isLoading = activities.find(
      (activity) => activity.transitionState === "enter-active" || activity.transitionState === "exit-active"
    );
    const globalTransitionState = stack.globalTransitionState === "paused" ? "paused" : isLoading ? "loading" : "idle";
    return reducer(__spreadProps(__spreadValues({}, stack), { activities, globalTransitionState }), event);
  };
}
function noop3(stack) {
  return stack;
}
function makeStackReducer(context) {
  return makeReducer({
    Initialized: withPauseReducer(
      withActivitiesReducer((stack, event) => {
        return __spreadProps(__spreadValues({}, stack), {
          transitionDuration: event.transitionDuration
        });
      }, context)
    ),
    ActivityRegistered: withPauseReducer(
      withActivitiesReducer(
        (stack, event) => {
          return __spreadProps(__spreadValues({}, stack), {
            registeredActivities: [
              ...stack.registeredActivities,
              __spreadValues({
                name: event.activityName
              }, event.activityParamsSchema ? {
                paramsSchema: event.activityParamsSchema
              } : null)
            ]
          });
        },
        context
      )
    ),
    Paused: withPauseReducer(
      withActivitiesReducer((stack, event) => {
        return __spreadProps(__spreadValues({}, stack), {
          globalTransitionState: "paused"
        });
      }, context)
    ),
    Resumed: withActivitiesReducer(
      (stack, event) => {
        if (stack.globalTransitionState !== "paused" || !stack.pausedEvents) {
          return stack;
        }
        const reducer = makeStackReducer({
          now: context.now,
          resumedAt: event.eventDate
        });
        const _a = stack, { pausedEvents } = _a, rest = __objRest(_a, ["pausedEvents"]);
        return pausedEvents.reduce(reducer, __spreadProps(__spreadValues({}, rest), {
          globalTransitionState: "idle"
        }));
      },
      context
    ),
    Pushed: withPauseReducer(withActivitiesReducer(noop3, context)),
    Replaced: withPauseReducer(withActivitiesReducer(noop3, context)),
    Popped: withPauseReducer(withActivitiesReducer(noop3, context)),
    StepPushed: withPauseReducer(withActivitiesReducer(noop3, context)),
    StepReplaced: withPauseReducer(withActivitiesReducer(noop3, context)),
    StepPopped: withPauseReducer(withActivitiesReducer(noop3, context))
  });
}

// src/event-utils/filterEvents.ts
function filterEvents(events, eventName) {
  return events.filter((e) => e.name === eventName);
}

// src/event-utils/makeEvent.ts
function makeEvent(name, parameters) {
  return __spreadProps(__spreadValues({
    id: id(),
    eventDate: time()
  }, parameters), {
    name
  });
}

// src/event-utils/validateEvents.ts
function validateEvents(events) {
  if (events.length === 0) {
    throw new Error("events parameter is empty");
  }
  const initEvents = filterEvents(events, "Initialized");
  if (initEvents.length > 1) {
    throw new Error("InitializedEvent can only exist once");
  }
  const activityRegisteredEvents = filterEvents(events, "ActivityRegistered");
  const registeredActivityNames = new Set(
    activityRegisteredEvents.map((e) => e.activityName)
  );
  const pushedEvents = filterEvents(events, "Pushed");
  if (pushedEvents.some((e) => !registeredActivityNames.has(e.activityName))) {
    throw new Error("the corresponding activity does not exist");
  }
}

// src/aggregate.ts
function aggregate(inputEvents, now) {
  const events = uniqBy(
    [...inputEvents].sort((a, b) => compareBy(a, b, (e) => e.id)),
    (e) => e.id
  );
  validateEvents(events);
  const stackReducer = makeStackReducer({ now });
  const stack = events.reduce(stackReducer, {
    activities: [],
    globalTransitionState: "idle",
    registeredActivities: [],
    transitionDuration: 0
  });
  const visibleActivities = stack.activities.filter(
    (activity) => activity.transitionState === "enter-active" || activity.transitionState === "enter-done" || activity.transitionState === "exit-active"
  );
  const enteredActivities = visibleActivities.filter(
    (activity) => activity.transitionState === "enter-active" || activity.transitionState === "enter-done"
  );
  const lastVisibleActivity = visibleActivities[visibleActivities.length - 1];
  const lastEnteredActivity = enteredActivities[enteredActivities.length - 1];
  const output = __spreadProps(__spreadValues({}, stack), {
    activities: stack.activities.map((activity) => {
      let zIndex = visibleActivities.findIndex(
        ({ id: id2 }) => id2 === activity.id
      );
      const beforeActivities = visibleActivities.slice(0, zIndex);
      for (const beforeActivity of beforeActivities) {
        for (const step of beforeActivity.steps) {
          if (step.hasZIndex) {
            zIndex += 1;
          }
        }
      }
      const steps = activity.steps.reduce((acc, step) => {
        var _a;
        const lastStep = last(acc);
        const lastStepZIndex = (_a = lastStep == null ? void 0 : lastStep.zIndex) != null ? _a : zIndex;
        return [
          ...acc,
          __spreadProps(__spreadValues({}, step), {
            zIndex: lastStepZIndex + (step.hasZIndex ? 1 : 0)
          })
        ];
      }, []);
      return __spreadValues(__spreadValues({
        id: activity.id,
        name: activity.name,
        transitionState: activity.transitionState,
        params: activity.params,
        steps,
        enteredBy: activity.enteredBy,
        zIndex,
        isTop: (lastVisibleActivity == null ? void 0 : lastVisibleActivity.id) === activity.id,
        isActive: (lastEnteredActivity == null ? void 0 : lastEnteredActivity.id) === activity.id,
        isRoot: zIndex === 0 || zIndex === 1 && activity.transitionState === "enter-active" && activity.enteredBy.name === "Replaced"
      }, activity.exitedBy ? {
        exitedBy: activity.exitedBy
      } : null), activity.context ? {
        context: activity.context
      } : null);
    }).sort((a, b) => compareBy(a, b, (activity) => activity.id))
  });
  return output;
}

// src/makeCoreStore.ts
import isEqual2 from "react-fast-compare";

// src/produceEffects.ts
import isEqual from "react-fast-compare";
function produceEffects(prevOutput, nextOutput) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const output = [];
  const somethingChanged = !isEqual(prevOutput, nextOutput);
  if (somethingChanged) {
    output.push({
      _TAG: "%SOMETHING_CHANGED%"
    });
  }
  const isPaused = prevOutput.globalTransitionState !== "paused" && nextOutput.globalTransitionState === "paused";
  const isResumed = prevOutput.globalTransitionState === "paused" && nextOutput.globalTransitionState !== "paused";
  if (isPaused) {
    output.push({
      _TAG: "PAUSED"
    });
  }
  if (isResumed) {
    output.push({
      _TAG: "RESUMED"
    });
  }
  for (let i = 0; i < Math.max(prevOutput.activities.length, nextOutput.activities.length); i += 1) {
    const prevActivity = prevOutput.activities[i];
    const nextActivity = nextOutput.activities[i];
    const isPrevActivityPopped = (prevActivity == null ? void 0 : prevActivity.transitionState) === "exit-done" || (prevActivity == null ? void 0 : prevActivity.transitionState) === "exit-active";
    const isNextActivityPushed = (nextActivity == null ? void 0 : nextActivity.transitionState) === "enter-active" || (nextActivity == null ? void 0 : nextActivity.transitionState) === "enter-done";
    if (prevActivity && nextActivity && prevActivity.id === nextActivity.id) {
      for (let j = 0; j < Math.max(
        ((_a = prevActivity.steps) != null ? _a : []).length,
        ((_b = nextActivity.steps) != null ? _b : []).length
      ); j += 1) {
        const prevStep = prevActivity.steps[j];
        const nextStep = nextActivity.steps[j];
        if (!prevStep && nextStep) {
          output.push({
            _TAG: "STEP_PUSHED",
            activity: nextActivity,
            step: nextStep
          });
        } else if (prevStep && !nextStep) {
          output.push({
            _TAG: "STEP_POPPED",
            activity: nextActivity
          });
        } else if (prevActivity.steps.length === nextActivity.steps.length && prevStep.id !== nextStep.id) {
          output.push({
            _TAG: "STEP_REPLACED",
            activity: nextActivity,
            step: nextStep
          });
        }
      }
    }
    if (!prevActivity && nextActivity) {
      output.push({
        _TAG: nextActivity.enteredBy.name === "Pushed" ? "PUSHED" : "REPLACED",
        activity: nextActivity
      });
    } else if (isPrevActivityPopped && isNextActivityPushed) {
      output.push({
        _TAG: nextActivity.enteredBy.name === "Pushed" ? "PUSHED" : "REPLACED",
        activity: nextActivity
      });
    } else if (prevActivity && nextActivity && prevActivity.id === nextActivity.id && !isEqual(
      omit(prevActivity, [
        "isActive",
        "isTop",
        "isRoot",
        "transitionState",
        "zIndex"
      ]),
      omit(nextActivity, [
        "isActive",
        "isTop",
        "isRoot",
        "transitionState",
        "zIndex"
      ])
    ) && nextActivity.enteredBy.name === "Replaced" && !isEqual(prevActivity.enteredBy, nextActivity.enteredBy)) {
      output.push({
        _TAG: "REPLACED",
        activity: nextActivity
      });
    }
  }
  for (let j = Math.max(prevOutput.activities.length, nextOutput.activities.length) - 1; j >= 0; j -= 1) {
    const isPrevActivityPushed = ((_c = prevOutput.activities[j]) == null ? void 0 : _c.transitionState) === "enter-done" || ((_d = prevOutput.activities[j]) == null ? void 0 : _d.transitionState) === "enter-active";
    const isNextActivityPopped = ((_e = nextOutput.activities[j]) == null ? void 0 : _e.transitionState) === "exit-active" || ((_f = nextOutput.activities[j]) == null ? void 0 : _f.transitionState) === "exit-done";
    const isReplacedEvent = ((_g = nextOutput.activities[j + 1]) == null ? void 0 : _g.enteredBy.name) === "Replaced" && ((_h = nextOutput.activities[j + 1]) == null ? void 0 : _h.transitionState) === "enter-done";
    if (isPrevActivityPushed && isNextActivityPopped && !isReplacedEvent) {
      output.push({
        _TAG: "POPPED",
        activity: nextOutput.activities[j]
      });
    }
  }
  return output;
}

// src/utils/triggerPreEffectHooks.ts
var PLUGIN_HOOK_MAP = {
  Pushed: "onBeforePush",
  Replaced: "onBeforeReplace",
  Popped: "onBeforePop",
  StepPushed: "onBeforeStepPush",
  StepReplaced: "onBeforeStepReplace",
  StepPopped: "onBeforeStepPop",
  Paused: "onBeforePause",
  Resumed: "onBeforeResume"
};
function triggerPreEffectHook(actionName, actionParams, pluginInstances, actions) {
  let isPrevented = false;
  let nextActionParams = __spreadValues({}, actionParams);
  for (const pluginInstance of pluginInstances) {
    const hook = pluginInstance[PLUGIN_HOOK_MAP[actionName]];
    if (hook) {
      hook({
        actionParams: __spreadValues({}, nextActionParams),
        actions: __spreadProps(__spreadValues({}, actions), {
          preventDefault: () => {
            isPrevented = true;
          },
          overrideActionParams: (partialActionParams) => {
            nextActionParams = __spreadValues(__spreadValues({}, nextActionParams), partialActionParams);
          }
        })
      });
    }
  }
  return {
    isPrevented,
    nextActionParams
  };
}

// src/utils/makeActions.ts
function makeActions({
  dispatchEvent,
  pluginInstances,
  actions
}) {
  return {
    push(params) {
      const { isPrevented, nextActionParams } = triggerPreEffectHook(
        "Pushed",
        params,
        pluginInstances,
        actions
      );
      if (isPrevented) {
        return;
      }
      dispatchEvent("Pushed", nextActionParams);
    },
    replace(params) {
      const { isPrevented, nextActionParams } = triggerPreEffectHook(
        "Replaced",
        params,
        pluginInstances,
        actions
      );
      if (isPrevented) {
        return;
      }
      dispatchEvent("Replaced", nextActionParams);
    },
    pop(params = {}) {
      const { isPrevented, nextActionParams } = triggerPreEffectHook(
        "Popped",
        params,
        pluginInstances,
        actions
      );
      if (isPrevented) {
        return;
      }
      dispatchEvent("Popped", nextActionParams);
    },
    stepPush(params) {
      const { isPrevented, nextActionParams } = triggerPreEffectHook(
        "StepPushed",
        params,
        pluginInstances,
        actions
      );
      if (isPrevented) {
        return;
      }
      dispatchEvent("StepPushed", nextActionParams);
    },
    stepReplace(params) {
      const { isPrevented, nextActionParams } = triggerPreEffectHook(
        "StepReplaced",
        params,
        pluginInstances,
        actions
      );
      if (isPrevented) {
        return;
      }
      dispatchEvent("StepReplaced", nextActionParams);
    },
    stepPop(params = {}) {
      const { isPrevented, nextActionParams } = triggerPreEffectHook(
        "StepPopped",
        params,
        pluginInstances,
        actions
      );
      if (isPrevented) {
        return;
      }
      dispatchEvent("StepPopped", nextActionParams);
    },
    pause(params = {}) {
      const { isPrevented, nextActionParams } = triggerPreEffectHook(
        "Paused",
        params,
        pluginInstances,
        actions
      );
      if (isPrevented) {
        return;
      }
      dispatchEvent("Paused", nextActionParams);
    },
    resume(params = {}) {
      const { isPrevented, nextActionParams } = triggerPreEffectHook(
        "Resumed",
        params,
        pluginInstances,
        actions
      );
      if (isPrevented) {
        return;
      }
      dispatchEvent("Resumed", nextActionParams);
    }
  };
}

// src/utils/triggerPostEffectHooks.ts
function triggerPostEffectHooks(effects, plugins, actions) {
  effects.forEach((effect) => {
    plugins.forEach((plugin) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i;
      switch (effect._TAG) {
        case "PUSHED":
          (_a = plugin.onPushed) == null ? void 0 : _a.call(plugin, { actions, effect });
          break;
        case "REPLACED":
          (_b = plugin.onReplaced) == null ? void 0 : _b.call(plugin, { actions, effect });
          break;
        case "POPPED":
          (_c = plugin.onPopped) == null ? void 0 : _c.call(plugin, { actions, effect });
          break;
        case "STEP_PUSHED":
          (_d = plugin.onStepPushed) == null ? void 0 : _d.call(plugin, { actions, effect });
          break;
        case "STEP_REPLACED":
          (_e = plugin.onStepReplaced) == null ? void 0 : _e.call(plugin, { actions, effect });
          break;
        case "STEP_POPPED":
          (_f = plugin.onStepPopped) == null ? void 0 : _f.call(plugin, { actions, effect });
          break;
        case "PAUSED":
          (_g = plugin.onPaused) == null ? void 0 : _g.call(plugin, { actions, effect });
          break;
        case "RESUMED":
          (_h = plugin.onResumed) == null ? void 0 : _h.call(plugin, { actions, effect });
          break;
        case "%SOMETHING_CHANGED%":
          (_i = plugin.onChanged) == null ? void 0 : _i.call(plugin, { actions, effect });
          break;
      }
    });
  });
}

// src/makeCoreStore.ts
var SECOND = 1e3;
var INTERVAL_MS = SECOND / 60;
function makeCoreStore(options) {
  var _a, _b, _c, _d;
  const storeListeners = [];
  const defaultPlugin = () => ({
    key: "@stackflow/core",
    onChanged() {
      storeListeners.forEach((listener) => listener());
    }
  });
  const pluginInstances = [
    defaultPlugin(),
    ...options.plugins.map((plugin) => plugin())
  ];
  const [initialPushedEventsByOption, initialRemainingEvents] = divideBy(
    options.initialEvents,
    (e) => e.name === "Pushed" || e.name === "StepPushed"
  );
  const initialPushedEvents = pluginInstances.reduce(
    (initialEvents, pluginInstance) => {
      var _a2, _b2, _c2;
      return (_c2 = (_b2 = pluginInstance.overrideInitialEvents) == null ? void 0 : _b2.call(pluginInstance, {
        initialEvents,
        initialContext: (_a2 = options.initialContext) != null ? _a2 : {}
      })) != null ? _c2 : initialEvents;
    },
    initialPushedEventsByOption
  );
  const isInitialActivityIgnored = initialPushedEvents.length > 0 && initialPushedEventsByOption.length > 0 && initialPushedEvents !== initialPushedEventsByOption;
  if (isInitialActivityIgnored) {
    (_b = (_a = options.handlers) == null ? void 0 : _a.onInitialActivityIgnored) == null ? void 0 : _b.call(_a, initialPushedEvents);
  }
  if (initialPushedEvents.length === 0) {
    (_d = (_c = options.handlers) == null ? void 0 : _c.onInitialActivityNotFound) == null ? void 0 : _d.call(_c);
  }
  const events = {
    value: [...initialRemainingEvents, ...initialPushedEvents]
  };
  const stack = {
    value: aggregate(events.value, (/* @__PURE__ */ new Date()).getTime())
  };
  const actions = {
    getStack() {
      return stack.value;
    },
    dispatchEvent(name, params) {
      const newEvent = makeEvent(name, params);
      const nextStackValue = aggregate(
        [...events.value, newEvent],
        (/* @__PURE__ */ new Date()).getTime()
      );
      events.value.push(newEvent);
      setStackValue(nextStackValue);
      const interval = setInterval(() => {
        const nextStackValue2 = aggregate(events.value, (/* @__PURE__ */ new Date()).getTime());
        if (!isEqual2(stack.value, nextStackValue2)) {
          setStackValue(nextStackValue2);
        }
        if (nextStackValue2.globalTransitionState === "idle") {
          clearInterval(interval);
        }
      }, INTERVAL_MS);
    },
    push: () => {
    },
    replace: () => {
    },
    pop: () => {
    },
    stepPush: () => {
    },
    stepReplace: () => {
    },
    stepPop: () => {
    },
    pause: () => {
    },
    resume: () => {
    }
  };
  const setStackValue = (nextStackValue) => {
    const effects = produceEffects(stack.value, nextStackValue);
    stack.value = nextStackValue;
    triggerPostEffectHooks(effects, pluginInstances, actions);
  };
  Object.assign(
    actions,
    makeActions({
      dispatchEvent: actions.dispatchEvent,
      pluginInstances,
      actions
    })
  );
  return {
    actions,
    init: once(() => {
      pluginInstances.forEach((pluginInstance) => {
        var _a2;
        (_a2 = pluginInstance.onInit) == null ? void 0 : _a2.call(pluginInstance, {
          actions
        });
      });
    }),
    pullEvents: () => events.value,
    subscribe(listener) {
      storeListeners.push(listener);
      return function dispose() {
        const listenerIndex = storeListeners.findIndex((l) => l === listener);
        if (listenerIndex > -1) {
          storeListeners.splice(listenerIndex, 1);
        }
      };
    },
    pluginInstances
  };
}
export {
  aggregate,
  id,
  makeCoreStore,
  makeEvent,
  produceEffects
};
//# sourceMappingURL=index.mjs.map
