"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  SWIPE_BACK_RATIO_CSS_VAR_NAME: () => SWIPE_BACK_RATIO_CSS_VAR_NAME,
  useActivityDataAttributes: () => useActivityDataAttributes,
  useAppBarTitleMaxWidth: () => useAppBarTitleMaxWidth,
  useLazy: () => useLazy,
  useMounted: () => useMounted,
  useNullableActivity: () => useNullableActivity,
  useStyleEffect: () => useStyleEffect,
  useStyleEffectHide: () => useStyleEffectHide,
  useStyleEffectOffset: () => useStyleEffectOffset,
  useStyleEffectSwipeBack: () => useStyleEffectSwipeBack,
  useZIndexBase: () => useZIndexBase
});
module.exports = __toCommonJS(src_exports);

// src/useLazy.tsx
var import_react = require("react");

// src/utils/listenOnce.ts
function listenOnce(el, types, cb) {
  const listener = () => {
    types.forEach((type) => {
      el.removeEventListener(type, listener);
    });
    cb();
  };
  types.forEach((type) => {
    el.addEventListener(type, listener);
  });
}

// src/utils/listenResize.ts
var listenResize = (cb) => {
  cb();
  window.addEventListener("resize", cb);
  return () => {
    window.removeEventListener("resize", cb);
  };
};

// src/utils/noop.ts
var noop = () => {
};

// src/utils/requestNextFrame.tsx
function requestNextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(() => {
      cb();
    });
  });
}

// src/useLazy.tsx
function useLazy(value) {
  const [state, setState] = (0, import_react.useState)(void 0);
  (0, import_react.useEffect)(() => {
    requestNextFrame(() => {
      setState(value);
    });
  }, [value]);
  return state;
}

// src/useAppBarTitleMaxWidth.ts
var import_react2 = require("react");
function useAppBarTitleMaxWidth({
  outerRef,
  innerRef,
  enable
}) {
  const [maxWidth, setMaxWidth] = (0, import_react2.useState)(void 0);
  (0, import_react2.useEffect)(() => {
    const $outer = outerRef && "current" in outerRef && outerRef.current;
    const $inner = innerRef.current;
    if (!enable || !$outer || !$inner) {
      return noop;
    }
    const dispose = listenResize(() => {
      const screenWidth = $outer.clientWidth;
      const leftWidth = $inner.offsetLeft;
      const centerWidth = $inner.clientWidth;
      const rightWidth = screenWidth - leftWidth - centerWidth;
      const sideMargin = Math.max(leftWidth, rightWidth);
      setMaxWidth(screenWidth - 2 * sideMargin);
    });
    return dispose;
  });
  return {
    maxWidth
  };
}

// src/useMounted.ts
var import_react3 = require("react");
function useMounted() {
  const [mounted, mount] = (0, import_react3.useReducer)(() => true, false);
  (0, import_react3.useEffect)(() => {
    mount();
  }, []);
  return mounted;
}

// src/useNullableActivity.ts
var import_react4 = require("@stackflow/react");
function useNullableActivity() {
  return (0, import_react4.useActivity)();
}

// src/useStyleEffect.ts
var import_react5 = require("react");
var connections = {};
function useStyleEffect({
  styleName,
  refs,
  effect,
  effectDeps
}) {
  const activity = useNullableActivity();
  (0, import_react5.useEffect)(() => {
    if (!activity) {
      return noop;
    }
    if (!connections[styleName]) {
      connections[styleName] = /* @__PURE__ */ new Map();
    }
    connections[styleName].set(activity.zIndex, {
      refs,
      hasEffect: !!effect
    });
    return () => {
      connections[styleName].delete(activity.zIndex);
    };
  }, [activity == null ? void 0 : activity.id, refs, effect]);
  (0, import_react5.useEffect)(() => {
    if (!activity) {
      return noop;
    }
    if (!effect) {
      return noop;
    }
    const refs2 = (() => {
      let arr = [];
      for (let i = 1; i <= activity.zIndex; i += 1) {
        const connection = connections[styleName].get(activity.zIndex - i);
        if (connection == null ? void 0 : connection.refs) {
          arr = [...arr, ...connection.refs];
        }
        if (connection == null ? void 0 : connection.hasEffect) {
          break;
        }
      }
      return arr;
    })();
    const cleanup = effect({
      activityTransitionState: activity.transitionState,
      refs: refs2
    });
    return () => {
      cleanup == null ? void 0 : cleanup();
    };
  }, [activity == null ? void 0 : activity.transitionState, ...effectDeps != null ? effectDeps : []]);
}

// src/useStyleEffectHide.ts
function useStyleEffectHide({
  refs
}) {
  useStyleEffect({
    styleName: "hide",
    refs,
    effect: ({ activityTransitionState, refs: refs2 }) => {
      const cleanup = () => {
        refs2.forEach((ref) => {
          if (!ref.current) {
            return;
          }
          const $ref = ref.current;
          $ref.style.display = "";
        });
      };
      switch (activityTransitionState) {
        case "enter-done": {
          refs2.forEach((ref) => {
            if (!ref.current) {
              return;
            }
            const $ref = ref.current;
            $ref.style.display = "none";
          });
          return () => {
            cleanup();
          };
        }
        default: {
          cleanup();
          return noop;
        }
      }
    }
  });
}

// src/useStyleEffectOffset.ts
function useStyleEffectOffset({
  refs,
  transitionDuration,
  offsetStyles,
  hasEffect = false
}) {
  useStyleEffect({
    styleName: "offset",
    refs,
    effect: hasEffect ? ({ activityTransitionState, refs: refs2 }) => {
      const cleanup = () => {
        requestNextFrame(() => {
          refs2.forEach((ref) => {
            if (!ref.current) {
              return;
            }
            const $el = ref.current;
            $el.style.transform = "";
            $el.style.opacity = "";
            listenOnce($el, ["transitionend", "transitioncancel"], () => {
              $el.style.transition = "";
            });
          });
        });
      };
      switch (activityTransitionState) {
        case "enter-active":
        case "enter-done": {
          refs2.forEach((ref) => {
            if (!ref.current) {
              return;
            }
            ref.current.style.transition = transitionDuration;
            ref.current.style.transform = offsetStyles.transform;
            ref.current.style.opacity = offsetStyles.opacity;
          });
          switch (activityTransitionState) {
            case "enter-done":
              return () => {
                cleanup();
              };
            default:
              return noop;
          }
        }
        case "exit-active":
        case "exit-done": {
          requestNextFrame(() => {
            cleanup();
          });
          return noop;
        }
        default: {
          return noop;
        }
      }
    } : void 0
  });
}

// src/useStyleEffectSwipeBack.ts
var SWIPE_BACK_RATIO_CSS_VAR_NAME = "--stackflow-swipe-back-ratio";
function useStyleEffectSwipeBack({
  dimRef,
  edgeRef,
  paperRef,
  appBarRef,
  offset,
  transitionDuration,
  preventSwipeBack,
  getActivityTransitionState,
  onSwipeStart,
  onSwipeMove,
  onSwipeEnd,
  onTransitionEnd
}) {
  useStyleEffect({
    styleName: "swipe-back",
    refs: [paperRef],
    effect: ({ refs }) => {
      if (preventSwipeBack) {
        return noop;
      }
      if (!dimRef.current || !edgeRef.current || !paperRef.current) {
        return noop;
      }
      const $dim = dimRef.current;
      const $edge = edgeRef.current;
      const $paper = paperRef.current;
      const $appBarRef = appBarRef == null ? void 0 : appBarRef.current;
      let x0 = null;
      let t0 = null;
      let x = null;
      let cachedRefs = [];
      const resetState = () => {
        x0 = null;
        t0 = null;
        x = null;
        cachedRefs = [];
      };
      let _rAFLock = false;
      function movePaper({ dx, ratio }) {
        if (!_rAFLock) {
          _rAFLock = true;
          requestAnimationFrame(() => {
            $dim.style.opacity = `${1 - ratio}`;
            $dim.style.transition = "0s";
            $paper.style.overflowY = "hidden";
            $paper.style.transform = `translate3d(${dx}px, 0, 0)`;
            $paper.style.transition = "0s";
            $appBarRef == null ? void 0 : $appBarRef.style.setProperty(
              SWIPE_BACK_RATIO_CSS_VAR_NAME,
              String(ratio)
            );
            refs.forEach((ref) => {
              var _a, _b;
              if (!ref.current) {
                return;
              }
              ref.current.style.transform = `translate3d(${-1 * (1 - ratio) * offset}px, 0, 0)`;
              ref.current.style.transition = "0s";
              if (((_a = ref.current.parentElement) == null ? void 0 : _a.style.display) === "none") {
                ref.current.parentElement.style.display = "block";
              }
              (_b = ref.current.parentElement) == null ? void 0 : _b.style.setProperty(
                SWIPE_BACK_RATIO_CSS_VAR_NAME,
                String(ratio)
              );
            });
            _rAFLock = false;
          });
        }
      }
      function resetPaper({ swiped }) {
        return new Promise((resolve) => {
          requestAnimationFrame(() => {
            $dim.style.opacity = `${swiped ? 0 : 1}`;
            $dim.style.transition = transitionDuration;
            $paper.style.overflowY = "hidden";
            $paper.style.transform = `translateX(${swiped ? "100%" : "0"})`;
            $paper.style.transition = transitionDuration;
            refs.forEach((ref) => {
              if (!ref.current) {
                return;
              }
              ref.current.style.transition = transitionDuration;
              ref.current.style.transform = `translate3d(${swiped ? "0" : `-${offset / 16}rem`}, 0, 0)`;
            });
            const _cachedRefs = [...cachedRefs];
            resolve();
            listenOnce($paper, ["transitionend", "transitioncancel"], () => {
              const _swiped = swiped || getActivityTransitionState() === "exit-active" || getActivityTransitionState() === "exit-done";
              $dim.style.opacity = "";
              $paper.style.overflowY = "";
              $paper.style.transform = "";
              $appBarRef == null ? void 0 : $appBarRef.style.removeProperty(SWIPE_BACK_RATIO_CSS_VAR_NAME);
              refs.forEach((ref, i) => {
                var _a;
                if (!ref.current) {
                  return;
                }
                const _cachedRef = _cachedRefs[i];
                if (_swiped) {
                  ref.current.style.transition = "";
                  ref.current.style.transform = "";
                  if (ref.current.parentElement) {
                    ref.current.parentElement.style.display = "";
                  }
                } else if (_cachedRef) {
                  ref.current.style.transition = _cachedRef.style.transition;
                  ref.current.style.transform = _cachedRef.style.transform;
                  if (ref.current.parentElement && _cachedRef.parentElement) {
                    ref.current.parentElement.style.display = _cachedRef.parentElement.style.display;
                  }
                }
                (_a = ref.current.parentElement) == null ? void 0 : _a.style.removeProperty(
                  SWIPE_BACK_RATIO_CSS_VAR_NAME
                );
              });
              onTransitionEnd == null ? void 0 : onTransitionEnd({ swiped });
            });
          });
        });
      }
      const onTouchStart = (e) => {
        var _a;
        const { activeElement } = document;
        (_a = activeElement == null ? void 0 : activeElement.blur) == null ? void 0 : _a.call(activeElement);
        x0 = x = e.touches[0].clientX;
        t0 = Date.now();
        cachedRefs = refs.map((ref) => {
          if (!ref.current) {
            return {
              style: {
                transform: "",
                transition: ""
              }
            };
          }
          return {
            style: {
              transform: ref.current.style.transform,
              transition: ref.current.style.transition
            },
            parentElement: ref.current.parentElement ? {
              style: {
                display: ref.current.parentElement.style.display
              }
            } : void 0
          };
        });
        onSwipeStart == null ? void 0 : onSwipeStart();
      };
      const onTouchMove = (e) => {
        if (!x0) {
          resetState();
          return;
        }
        x = e.touches[0].clientX;
        const dx = x - x0;
        const ratio = dx / $paper.clientWidth;
        movePaper({ dx, ratio });
        onSwipeMove == null ? void 0 : onSwipeMove({ dx, ratio });
      };
      const onTouchEnd = () => {
        if (!x0 || !t0 || !x) {
          resetState();
          return;
        }
        const t = Date.now();
        const v = (x - x0) / (t - t0);
        const swiped = v > 1 || x / $paper.clientWidth > 0.4;
        onSwipeEnd == null ? void 0 : onSwipeEnd({ swiped });
        Promise.resolve().then(() => resetPaper({ swiped })).then(() => resetState());
      };
      $edge.addEventListener("touchstart", onTouchStart, { passive: true });
      $edge.addEventListener("touchmove", onTouchMove, { passive: true });
      $edge.addEventListener("touchend", onTouchEnd, { passive: true });
      $edge.addEventListener("touchcancel", onTouchEnd, { passive: true });
      return () => {
        $edge.removeEventListener("touchstart", onTouchStart);
        $edge.removeEventListener("touchmove", onTouchMove);
        $edge.removeEventListener("touchend", onTouchEnd);
        $edge.removeEventListener("touchcancel", onTouchEnd);
      };
    },
    effectDeps: []
  });
}

// src/useZIndexBase.ts
function useZIndexBase() {
  var _a;
  const activity = useNullableActivity();
  return ((_a = activity == null ? void 0 : activity.zIndex) != null ? _a : 0) * 5;
}

// src/useActivityDataAttributes.ts
function useActivityDataAttributes() {
  const activity = useNullableActivity();
  const mounted = useMounted();
  return __spreadValues({}, mounted ? {
    "data-stackflow-activity-id": activity == null ? void 0 : activity.id,
    "data-stackflow-activity-is-active": activity == null ? void 0 : activity.isActive,
    "data-stackflow-activity-transition-state": activity == null ? void 0 : activity.transitionState
  } : null);
}
//# sourceMappingURL=index.js.map
